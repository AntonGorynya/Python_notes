# Параметры функций
```
def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):
      -----------    ----------     ----------
        |             |                  |
        |        Positional or keyword   |
        |                                - Keyword only
         -- Positional only
```
### Проблема 1
Сами функции выполняют одну логическую задачу и позволяют избегать повторов в коде. Собвстено стоит задача переиспользовать код, наличие параметров делает его более универсальным.
Параметры могут быть 2х типов:  именованные и позиционные.  
### Решение 
```
def some_func(a,b,c, debug=True, name='123'):
  pass
```
- (+) Упрощение, параметризация кода
- (+) Значения по умолчанию упращают вызов функции
- (-) Переменные должны иметь понятные названия, иначе будет не понятно за что они отвечают
- (-) Позиционных аргументов может быть слишком много и заполнять их утомитеельо
- (-) В именнованые переменые можно поставить слишком много значений по умолчанию, и соотвесвенно будет много попыток вызвать функцию без них, те от от большого их кол-во так же может быть путаница.
- (-) Не стоит передвать в качестве аргумента функции словарь параметров.

### Проблема 2
Аргументы по умолчанию `def f(a,b)` a и b  могут быть переданы, как `def f(1,2)`, так и через ключи `def f(1,b=2)`. 
При написании функции, которая делает некую абстрацию, имена аргументов как правило не приносят ясности и соответсвенно можно укзать их как позиционные. Используя спец символ  `/`
```
def sum(a, j, /):
  return a+j
```
- (+) Позволяет зафиксирофать переменные как позиционные
- (+) Если переменная планируется переименоваться, то это позволит избежать проблем совместимости

### Проблема 3
Параметров много, и что бы сделать обявление более понятным как для того, кто читает, так и для того кто пишет можно использовать именованные аргумены Используя спец символ  `*`
```
def add_da(*, user_id=None, chat_id=None):
  return a+j
```
- (+) Позволяет зафиксирофать переменные как именные
- (+) упрощает чтение кода
- (-) усложняет написание кода

### Проблема 4
Передача неопределеного кол-во аргументов функции. для этого есть спец символ распоковки перед аргументом `*` для списков и `**` для словарей.
```
def concat(*args, sep="/"):
    return sep.join(args)

concat(arg1, arg2)
concat(*[arg1, arg2])
```
пример для словарей
```
def parrot(voltage, state='a stiff', action='voom'):
    print("-- This parrot wouldn't", action, end=' ')
    print("if you put", voltage, "volts through it.", end=' ')
    print("E's", state, "!")

d = {"voltage": "four million", "state": "bleedin' demised", "action": "VOOM"}
parrot(**d)
-- This parrot wouldn't VOOM if you put four million volts through it. E's bleedin' demised !
```
- (+) позволяет написать более универсальные функции
- (-) Неявная передача параметровов, не всегда видно, что  и зачем передаем.
- (-) Могут копится мусорные аргументы  

