# Параметры функций
```
def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):
      -----------    ----------     ----------
        |             |                  |
        |        Positional or keyword   |
        |                                - Keyword only
         -- Positional only
```
### Проблема 1
Сами функции выполняют одну логическую задачу и позволяют избегать повторов в коде. Собственно стоит задача переиспользовать код, наличие параметров делает его более универсальным.
Параметры могут быть 2‑х типов: именованные и позиционные.  
```
def some_func(a,b,c, debug=True, name='123'):
  pass
```
- (+) Упрощение, параметризация кода
- (+) Значения по умолчанию упрощают вызов функции
- (-) Переменные должны иметь понятные названия, иначе будет не понятно за что они отвечают
- (-) Позиционных аргументов может быть слишком много и заполнять их дольше, чем позиционных
- (-) В именованные переменные можно поставить слишком много значений по умолчанию, и соответственно будет много попыток вызвать функцию без них, те от большого их кол-во так же может быть путаница.
- (-) Не стоит передавать в качестве аргумента функции словарь параметров. Это ухудшит читаемость

Другие пути решения:
Использование классов

### Проблема 2
Аргументы по умолчанию `def f(a,b)` a и b могут быть переданы, как `def f(1,2)`, так и через ключи `def f(1,b=2)`. 
При написании функции, которая делает некую абстракцию, имена аргументов, как правило, не приносят ясности и соответственно можно указать их как позиционные. Используя спец символ  `/`
```
def sum(a, j, /):
  return a+j
```
- (+) Позволяет зафиксировать переменные как позиционные
- (+) Если переменная планируется переименоваться, то это позволит избежать проблем совместимости
- (+) Улучшает совместимость при разработке API
- (-) Хуже читается, чем именованные

Другие пути решения: Использование именованных аргументов

### Проблема 3
Параметров много, и что бы сделать объявление более понятным как для того, кто читает, так и для того кто пишет можно использовать именованные аргументы Используя спец символ  `*`
```
def add_da(*, user_id=None, chat_id=None):
  return a+j
```
- (+) Позволяет зафиксировать переменные как именные
- (+) упрощает чтение кода
- (-) усложняет написание кода

Другие пути решения: Использование позиционных аргументов

### Проблема 4
Передача неопределенного кол-во аргументов функции. Для этого есть спец символ распаковки перед аргументом `*` для списков и `**` для словарей.
```
def concat(*args, sep="/"):
    return sep.join(args)

concat(arg1, arg2)
concat(*[arg1, arg2])
```
Пример для словарей
```
def parrot(voltage, state='a stiff', action='voom'):
    print("-- This parrot wouldn't", action, end=' ')
    print("if you put", voltage, "volts through it.", end=' ')
    print("E's", state, "!")

d = {"voltage": "four million", "state": "bleedin' demised", "action": "VOOM"}
parrot(**d)
-- This parrot wouldn't VOOM if you put four million volts through it. E's bleedin' demised !
```
- (+) позволяет написать более универсальные функции
- (-) Неявная передача параметров, не всегда видно, что и зачем передаем.
- (-) Могут копится мусорные аргументы  

Другие способы решения: Не передавать списки и словари в качестве аргументов. Для каждого значения словаря\списка завести свой аргумент.
